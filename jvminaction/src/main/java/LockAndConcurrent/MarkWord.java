package LockAndConcurrent;

/**
 * Created by wangbo on 2018/3/17.
 *
 * 每个对象中有一个对象头 用于保存对象的系统信息
 * 对象头中有个Mark word的部分 是实现锁的关键
 * 32系统中 mw 32位 64系统中 mw 64位
 * 32位系统中 对象头如下所示
 * hash:25 -------->|age:4 biased_lock:1 lock:2
 * 25比特表示对象的hash值 4位表示对象的年龄 1位表示是否为偏向锁 2位表示锁的信息
 *
 *
 * 轻量级锁
 * BasicLock备份原对象的Mark word 接着使用cas操作 将basicLock的地址复制到
 * 对象头的Mark word 如果复制成功 那么加锁成功 如果加锁失败 那么轻量级锁就
 * 有可能被膨胀为重量级锁
 *
 * 锁膨胀
 * 轻量级锁失败后 会进行锁膨胀操作 获取对象的ObjectMonitor 然后使用enter()
 * 方法尝试进入该锁 enter调用中 线程可能会在操作系统层面挂起
 *
 * 自旋锁
 * 自旋锁可以使线程在没有取得锁时 不被挂起 转而去执行一个空循环 若干次空循环后
 * 线程可以获取锁 则继续执行 若线程依然不能获取锁 才会被挂起
 * 1.6中 使用-XX:+UseSpinning开启自旋锁 使用-XX:PreBlockSpin设置自旋锁等待次数
 * 1.7中 自旋锁参数被取消 不能配置
 * 注意:对于锁竞争不是很激烈 锁占用时间很短的并发线程 具有一定的积极意义
 *     但对于所竞争激烈 单线程锁占用时间长的并发程序 自旋锁在等待后往往依然无法
 *     获取对应的锁 不仅白白浪费了cpu时间 最终还免不了被挂起 反而浪费了系统资源
 *
 */
public class MarkWord {

}
